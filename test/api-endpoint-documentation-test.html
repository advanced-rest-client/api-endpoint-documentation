<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-endpoint-documentation test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <script src="./amf-loader.js"></script>

  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <script src="../../../codemirror/addon/lint/lint.js"></script>
  <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>
  <script>
  /* global CodeMirror */
  CodeMirror.modeURL = '../../../codemirror/mode/%N/%N.js';
  </script>
  <script src="../../../cryptojslib/components/core.js"></script>
  <script src="../../../cryptojslib/rollups/sha1.js"></script>
  <script src="../../../cryptojslib/components/enc-base64-min.js"></script>
  <script src="../../../cryptojslib/rollups/md5.js"></script>
  <script src="../../../cryptojslib/rollups/hmac-sha1.js"></script>
  <script src="../../../jsrsasign/lib/jsrsasign-rsa-min.js"></script>
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <api-endpoint-documentation></api-endpoint-documentation>
    </template>
  </test-fixture>

  <test-fixture id="Aware">
    <template>
      <api-endpoint-documentation aware="test"></api-endpoint-documentation>
    </template>
  </test-fixture>

  <test-fixture id="BaseUri">
    <template>
      <api-endpoint-documentation base-uri="https://domain.com"></api-endpoint-documentation>
    </template>
  </test-fixture>

  <script type="module">
  import '../api-endpoint-documentation.js';
  /* global AmfLoader */

  function getEndpoint(element, amf, endpoint) {
    const webApi = element._computeWebApi(amf);
    return element._computeEndpointByPath(webApi, endpoint);
  }

  // function getMethod(element, amf, endpoint, method) {
  //   const endPoint = getEndpoint(element, amf, endpoint);
  //   const opKey = element._getAmfKey(element.ns.w3.hydra.supportedOperation);
  //   const ops = element._ensureArray(endPoint[opKey]);
  //   return ops.find((item) => element._getValue(item, element.ns.w3.hydra.core + 'method') === method);
  // }

  suite('api-endpoint-documentation', () => {
    suite('Basic', () => {
      test('Adds raml-aware to the DOM if aware is set', (done) => {
        const element = fixture('Aware');
        flush(() => {
          const node = element.shadowRoot.querySelector('raml-aware');
          assert.ok(node);
          done();
        });
      });

      test('raml-aware is not in the DOM by default', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector('raml-aware');
          assert.notOk(node);
          done();
        });
      });

      test('api-annotation-document is not in the DOM', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector('api-annotation-document');
          assert.notOk(node);
          done();
        });
      });

      test('marked-element is not in the DOM', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector('marked-element');
          assert.notOk(node);
          done();
        });
      });

      test('api-parameters-document is not in the DOM', (done) => {
        const element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector('api-parameters-document');
          assert.notOk(node);
          done();
        });
      });
    });

    suite('AMF related computations', () => {
      [
        ['Full model', false],
        ['Compact model', true]
      ]
      .forEach((item) => {
        suite(item[0], () => {
          let element;
          let endpoint;
          let amf;
          suiteSetup((done) => {
            AmfLoader.load(0, item[1])
            .then((data) => {
              amf = data[0];
              endpoint = data[1];
              element = fixture('Basic');
              element.amfModel = amf;
              element.endpoint = endpoint;
              flush(() => done());
            });
          });

          test('endpointName is computed', () => {
            assert.equal(element.endpointName, 'People');
          });

          test('path is computed', () => {
            assert.equal(element.path, '/people');
          });

          test('description is computed', () => {
            assert.typeOf(element.description, 'string');
          });

          test('hasCustomProperties is computed', () => {
            assert.isTrue(element.hasCustomProperties);
          });

          test('extendsTypes is computed', () => {
            assert.typeOf(element.extendsTypes, 'array');
            assert.lengthOf(element.extendsTypes, 3);
          });

          test('parentType is computed', () => {
            assert.typeOf(element.parentType, 'object');
          });

          test('hasParentType is true', () => {
            assert.isTrue(element.hasParentType);
          });

          test('parentTypeName is computed', () => {
            assert.equal(element.parentTypeName, 'ResourceNotFound');
          });

          test('traits is computed', () => {
            assert.typeOf(element.traits, 'array');
            assert.lengthOf(element.traits, 2);
          });

          test('hasTraits is true', () => {
            assert.isTrue(element.hasTraits);
          });

          test('hasExtension is true', () => {
            assert.isTrue(element.hasExtension);
          });
        });
      });
    });

    suite('AMF - DOM content', () => {
      [
        ['Full model', false],
        ['Compact model', true]
      ]
      .forEach((item) => {
        suite(item[0], () => {
          let element;
          let endpoint;
          let amf;
          suiteSetup((done) => {
            AmfLoader.load(0, item[1])
            .then((data) => {
              amf = data[0];
              endpoint = data[1];
              element = fixture('Basic');
              element.amfModel = amf;
              element.endpoint = endpoint;
              flush(() => done());
            });
          });

          test('api-annotation-document is rendered', () => {
            const node = element.shadowRoot.querySelector('api-annotation-document');
            assert.ok(node);
          });

          test('marked-element is rendered', () => {
            const node = element.shadowRoot.querySelector('marked-element');
            assert.ok(node);
          });

          test('Extensions are rendered', () => {
            const node = element.shadowRoot.querySelector('.extensions');
            assert.ok(node);
          });

          test('Resource type name is rendered', () => {
            const node = element.shadowRoot.querySelector('.resource-type-name');
            assert.ok(node);
          });

          test('Trait name is rendered', () => {
            const node = element.shadowRoot.querySelector('.trait-name');
            assert.ok(node);
          });
        });
      });
    });

    suite('Full AMF model', () => {
      [
        ['Full model', false],
        ['Compact model', true]
      ]
      .forEach((item) => {
        suite(item[0], () => {
          let element;
          let endpoint;
          let amf;
          suiteSetup((done) => {
            AmfLoader.load(0, item[1])
            .then((data) => {
              amf = data[0];
              endpoint = data[1];
              element = fixture('Basic');
              element.amfModel = amf;
              element.endpoint = endpoint;
              flush(() => done());
            });
          });

          test('Renders title when display name', (done) => {
            AmfLoader.load(0)
            .then((data) => {
              element = fixture('Basic');
              element.amfModel = data[0];
              element.endpoint = data[1];
              flush(() => {
                const title = element.shadowRoot.querySelector('.title');
                assert.ok(title);
                done();
              });
            });
          });

          test('Hides title when no display name', (done) => {
            AmfLoader.load(3)
            .then((data) => {
              element = fixture('Basic');
              element.amfModel = data[0];
              element.endpoint = data[1];
              flush(() => {
                const title = element.shadowRoot.querySelector('.title');
                assert.notOk(title);
                done();
              });
            });
          });
        });
      });
    });

    suite('AMF model without traits and extensions', () => {
      [
        ['Full model', false],
        ['Compact model', true]
      ]
      .forEach((item) => {
        suite(item[0], () => {
          suite('Properties computations', () => {
            let element;
            let amf;
            suiteSetup((done) => {
              AmfLoader.load(0, item[1])
              .then((data) => {
                amf = data[0];
                element = fixture('Basic');
                element.amfModel = amf;
                element.endpoint = getEndpoint(element, amf, '/notypes');
                flush(() => done());
              });
            });

            test('traits is not computed', () => {
              assert.isUndefined(element.traits);
            });

            test('hasTraits is not computed', () => {
              assert.isUndefined(element.hasTraits);
            });

            test('hasExtension is not computed', () => {
              assert.isUndefined(element.hasExtension);
            });
          });

          suite('DOM content', () => {
            let element;
            let amf;
            setup((done) => {
              AmfLoader.load(0, item[1])
              .then((data) => {
                amf = data[0];
                element = fixture('Basic');
                element.amfModel = amf;
                element.endpoint = getEndpoint(element, amf, '/notypes');
                flush(() => done());
              });
            });

            test('Extensions are not rendered', () => {
              const node = element.shadowRoot.querySelector('.extensions');
              assert.notOk(node);
            });
          });
        });
      });
    });

    suite('Resource type computations', () => {
      [
        ['Full model', false],
        ['Compact model', true]
      ]
      .forEach((item) => {
        suite(item[0], () => {
          suite('Properties computations', () => {
            let element;
            let amf;
            suiteSetup((done) => {
              AmfLoader.load(0, item[1])
              .then((data) => {
                amf = data[0];
                element = fixture('Basic');
                element.amfModel = amf;
                element.endpoint = getEndpoint(element, amf, '/people/{personId}');
                flush(() => done());
              });
            });

            test('traits is not computed', () => {
              assert.isUndefined(element.traits);
            });

            test('hasTraits is not computed', () => {
              assert.isUndefined(element.hasTraits);
            });

            test('hasExtension is computed', () => {
              assert.isTrue(element.hasExtension);
            });

            test('hasParentType is computed', () => {
              assert.isTrue(element.hasParentType);
            });
          });

          suite('DOM content', () => {
            let element;
            let amf;
            setup((done) => {
              AmfLoader.load(0, item[1])
              .then((data) => {
                amf = data[0];
                element = fixture('Basic');
                element.amfModel = amf;
                element.endpoint = getEndpoint(element, amf, '/people/{personId}');
                flush(() => done());
              });
            });

            test('Extensions node is rendered', () => {
              const node = element.shadowRoot.querySelector('.extensions');
              assert.ok(node);
            });

            test('Resource type name is rendered', () => {
              const node = element.shadowRoot.querySelector('.resource-type-name');
              assert.ok(node);
            });

            test('Trait name is not rendered', () => {
              const node = element.shadowRoot.querySelector('.trait-name');
              assert.notOk(node);
            });
          });
        });
      });
    });

    suite('AMF model with traits only', () => {
      [
        ['Full model', false],
        ['Compact model', true]
      ]
      .forEach((item) => {
        suite(item[0], () => {
          suite('Properties computations', () => {
            let element;
            suiteSetup((done) => {
              AmfLoader.load(0, item[1])
              .then((data) => {
                const amf = data[0];
                element = fixture('Basic');
                element.amfModel = amf;
                element.endpoint = getEndpoint(element, amf, '/products');
                flush(() => done());
              });
            });

            test('parentType is not computed', () => {
              assert.isUndefined(element.parentType);
            });

            test('hasParentType is not computed', () => {
              assert.isUndefined(element.hasParentType);
            });

            test('parentTypeName is not computed', () => {
              assert.isUndefined(element.parentTypeName);
            });

            test('traits is computed', () => {
              assert.typeOf(element.traits, 'array');
              assert.lengthOf(element.traits, 1);
            });

            test('hasTraits is true', () => {
              assert.isTrue(element.hasTraits);
            });

            test('hasExtension is true', () => {
              assert.isTrue(element.hasExtension);
            });
          });

          suite('DOM content', () => {
            let element;
            setup((done) => {
              AmfLoader.load(0, item[1])
              .then((data) => {
                const amf = data[0];
                element = fixture('Basic');
                element.amfModel = amf;
                element.endpoint = getEndpoint(element, amf, '/products');
                flush(() => done());
              });
            });

            test('Extensions node is rendered', () => {
              const node = element.shadowRoot.querySelector('.extensions');
              assert.ok(node);
            });

            test('Resource type name is not rendered', () => {
              const node = element.shadowRoot.querySelector('.resource-type-name');
              assert.notOk(node);
            });

            test('Trait name is rendered', () => {
              const node = element.shadowRoot.querySelector('.trait-name');
              assert.ok(node);
            });
          });
        });
      });
    });

    suite('Bottom navigation', () => {
      let element;
      let prev = {'label': 'p', 'id': 'pp'};
      let next = {'label': 'n', 'id': 'nn'};
      test('hasPagination is undefined by default', () => {
        element = fixture('Basic');
        assert.isUndefined(element.hasPagination);
      });
      test('Does not render bottom navigation when nothing is set', (done) => {
        element = fixture('Basic');
        flush(() => {
          const node = element.shadowRoot.querySelector('.bottom-nav');
          assert.notOk(node);
          done();
        });
      });
      test('hasPreviousLink is computed for "previous" data', () => {
        element = fixture('Basic');
        element.previous = prev;
        assert.isTrue(element.hasPreviousLink);
      });
      test('hasPagination is computed for "previous" data', () => {
        element = fixture('Basic');
        element.previous = prev;
        assert.isTrue(element.hasPagination);
      });
      test('hasNextLink is computed for "next" data', () => {
        element = fixture('Basic');
        element.next = next;
        assert.isTrue(element.hasNextLink);
      });
      test('hasPagination is computed for "next" data', () => {
        element = fixture('Basic');
        element.next = next;
        assert.isTrue(element.hasPagination);
      });
      test('Renders bottom navigation', (done) => {
        element = fixture('Basic');
        element.next = next;
        element.previous = prev;
        flush(() => {
          const node = element.shadowRoot.querySelector('.bottom-nav');
          assert.ok(node);
          done();
        });
      });
      test('Renders previous buttons', (done) => {
        element = fixture('Basic');
        element.previous = prev;
        flush(() => {
          const node = element.shadowRoot.querySelector('.bottom-link.previous');
          assert.ok(node);
          done();
        });
      });
      test('Renders next buttons', (done) => {
        element = fixture('Basic');
        element.next = next;
        flush(() => {
          const node = element.shadowRoot.querySelector('.bottom-link.next');
          assert.ok(node);
          done();
        });
      });
      test('Does not render previous for next only', (done) => {
        element = fixture('Basic');
        element.next = next;
        flush(() => {
          const node = element.shadowRoot.querySelector('.bottom-link.previous');
          assert.notOk(node);
          done();
        });
      });
      test('Does not render next for previous only', (done) => {
        element = fixture('Basic');
        element.previous = prev;
        flush(() => {
          const node = element.shadowRoot.querySelector('.bottom-link.next');
          assert.notOk(node);
          done();
        });
      });
    });
  });
  </script>
</body>
</html>
